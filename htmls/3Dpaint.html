<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>VR Painter 3D</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    #ui {
      position: fixed; top: 10px; left: 10px;
      background: rgba(0,0,0,0.9); padding: 12px; border-radius: 10px;
      color: #fff; width: 220px; font-family: system-ui; font-size: 11px; z-index: 9999;
    }
    h2 { font-size: 14px; color: #0ff; text-align: center; margin-bottom: 10px; }
    h3 { font-size: 11px; color: #f0f; margin: 10px 0 5px; border-top: 1px solid #333; padding-top: 8px; }
    label { display: block; font-size: 10px; margin: 4px 0 2px; color: #aaa; }
    input[type="range"] { width: 100%; }
    input[type="color"] { width: 40px; height: 25px; border: none; border-radius: 4px; cursor: pointer; }
    button { width: 100%; padding: 6px; margin: 3px 0; border: none; border-radius: 4px; background: linear-gradient(135deg, #0ff, #f0f); color: #000; font-weight: bold; font-size: 10px; cursor: pointer; }
    button:hover { opacity: 0.85; }
    button.secondary { background: #333; color: #fff; }
    button.danger { background: #c33; color: #fff; }
    button.active { background: #0f0; color: #000; }
    .btn-row { display: flex; gap: 4px; }
    .btn-row button { flex: 1; }
    .section { background: #1a1a1a; padding: 8px; border-radius: 6px; margin: 5px 0; }
    .color-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; margin: 5px 0; }
    .color-btn { width: 100%; aspect-ratio: 1; border: 2px solid transparent; border-radius: 4px; cursor: pointer; }
    .color-btn.active { border-color: #fff; }
    .brush-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 3px; }
    #toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #0ff; color: #000; padding: 8px 16px; border-radius: 6px; font-weight: bold; display: none; z-index: 10000; }
    #statusBar { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 6px; color: #0ff; font-family: monospace; font-size: 11px; z-index: 9999; }
    #help { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; color: #888; font-size: 10px; z-index: 9999; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>üé® VR Painter 3D</h2>
    
    <div class="btn-row">
      <button id="btnDraw" class="active" onclick="setTool('draw')">‚úèÔ∏è Desenhar</button>
      <button id="btnErase" class="secondary" onclick="setTool('erase')">üßπ Apagar</button>
    </div>
    
    <h3>üé® Cor</h3>
    <div class="section">
      <div class="color-grid" id="colorPalette"></div>
      <div class="btn-row" style="margin-top:5px">
        <label>Custom:</label>
        <input type="color" id="customColor" value="#00ffff" onchange="setColor(this.value)">
      </div>
    </div>
    
    <h3>üñåÔ∏è Pincel</h3>
    <div class="section">
      <div class="brush-grid">
        <button class="secondary" onclick="setBrush('sphere')">‚óè Esfera</button>
        <button class="secondary" onclick="setBrush('box')">‚ñ† Cubo</button>
        <button class="secondary" onclick="setBrush('star')">‚òÖ Estrela</button>
      </div>
      <label>Tamanho: <span id="sizeVal">0.05</span></label>
      <input type="range" id="brushSize" min="0.01" max="0.3" step="0.01" value="0.05" oninput="updateSize()">
      <label>Espa√ßamento: <span id="spacingVal">0.03</span></label>
      <input type="range" id="spacing" min="0.01" max="0.2" step="0.01" value="0.03" oninput="updateSpacing()">
    </div>
    
    <h3>‚ú® Efeitos</h3>
    <div class="section">
      <label><input type="checkbox" id="glowEnabled" onchange="updateGlow()"> Brilho (Emissivo)</label>
      <label><input type="checkbox" id="rainbowMode"> Modo Arco-√≠ris</label>
      <label><input type="checkbox" id="mirrorMode"> Espelho (X)</label>
      <label>Metalness: <span id="metalVal">0</span></label>
      <input type="range" id="metalness" min="0" max="1" step="0.1" value="0" oninput="updateMetal()">
    </div>
    
    <h3>üé¨ A√ß√µes</h3>
    <div class="section">
      <button onclick="undoLast()" class="secondary">‚Ü©Ô∏è Desfazer (Ctrl+Z)</button>
      <button onclick="clearAll()" class="danger">üóëÔ∏è Limpar Tudo</button>
      <div class="btn-row">
        <button onclick="exportScene()" class="secondary">üíæ Salvar</button>
        <button onclick="document.getElementById('importFile').click()" class="secondary">üìÇ Carregar</button>
      </div>
      <input type="file" id="importFile" accept=".json" style="display:none" onchange="importScene(event)">
    </div>
  </div>
  
  <div id="statusBar">Ferramenta: Desenhar | Cor: #00ffff | Strokes: 0</div>
  <div id="help">
    WASD: mover | Mouse: olhar<br>
    Clique+Arraste: pintar<br>
    Ctrl+Z: desfazer | C: limpar
  </div>
  <div id="toast"></div>

  <a-scene id="scene" vr-mode-ui="enabled: true">
    <a-entity id="rig" position="0 1.6 4">
      <a-camera id="camera" look-controls wasd-controls="acceleration: 20">
        <!-- Cursor/brush indicator -->
        <a-entity id="brushCursor" position="0 0 -1.5">
          <a-sphere radius="0.05" material="color: #0ff; opacity: 0.5; transparent: true"></a-sphere>
          <a-ring radius-inner="0.06" radius-outer="0.08" material="color: #fff; shader: flat" rotation="0 0 0"></a-ring>
        </a-entity>
      </a-camera>
    </a-entity>
    
    <!-- VR Controllers -->
    <a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .paintable; far: 10"></a-entity>
    <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .paintable; far: 10">
      <a-sphere radius="0.02" position="0 0 -0.05" material="color: #0ff; shader: flat"></a-sphere>
    </a-entity>
    
    <a-light type="ambient" color="#888" intensity="0.6"></a-light>
    <a-light type="directional" color="#fff" intensity="0.7" position="2 4 2"></a-light>
    <a-light type="point" color="#0ff" intensity="0.3" position="3 2 3"></a-light>
    <a-light type="point" color="#f0f" intensity="0.3" position="-3 2 -3"></a-light>
    
    <a-sky color="#111122"></a-sky>
    <a-plane class="paintable" rotation="-90 0 0" width="20" height="20" color="#1a1a1a" material="side: double"></a-plane>
    <a-entity id="grid" position="0 0.01 0"></a-entity>
    
    <!-- Paint container -->
    <a-entity id="paintContainer"></a-entity>
  </a-scene>

  <script>
    // State
    let currentColor = '#00ffff';
    let currentBrush = 'sphere';
    let brushSize = 0.05;
    let spacing = 0.03;
    let currentTool = 'draw';
    let isPainting = false;
    let lastPaintPos = null;
    let strokes = []; // Array of stroke arrays for undo
    let currentStroke = [];
    let strokeCount = 0;
    let hue = 0;
    
    const container = document.getElementById('paintContainer');
    const brushCursor = document.getElementById('brushCursor');
    
    // Color palette
    const colors = [
      '#ff0000', '#ff8800', '#ffff00', '#00ff00', '#00ffff', '#0088ff',
      '#0000ff', '#8800ff', '#ff00ff', '#ff0088', '#ffffff', '#000000'
    ];
    
    function initPalette() {
      const palette = document.getElementById('colorPalette');
      colors.forEach(c => {
        const btn = document.createElement('div');
        btn.className = 'color-btn' + (c === currentColor ? ' active' : '');
        btn.style.background = c;
        btn.onclick = () => setColor(c);
        palette.appendChild(btn);
      });
    }
    
    function setColor(color) {
      currentColor = color;
      document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
      const match = [...document.querySelectorAll('.color-btn')].find(b => b.style.background === color);
      if (match) match.classList.add('active');
      document.getElementById('customColor').value = color;
      updateCursor();
      updateStatus();
    }
    
    function setBrush(type) {
      currentBrush = type;
      showToast(`Pincel: ${type}`);
    }
    
    function setTool(tool) {
      currentTool = tool;
      document.getElementById('btnDraw').className = tool === 'draw' ? 'active' : 'secondary';
      document.getElementById('btnErase').className = tool === 'erase' ? 'active' : 'secondary';
      updateStatus();
    }
    
    function updateSize() {
      brushSize = parseFloat(document.getElementById('brushSize').value);
      document.getElementById('sizeVal').textContent = brushSize.toFixed(2);
      updateCursor();
    }
    
    function updateSpacing() {
      spacing = parseFloat(document.getElementById('spacing').value);
      document.getElementById('spacingVal').textContent = spacing.toFixed(2);
    }
    
    function updateGlow() {}
    function updateMetal() {
      document.getElementById('metalVal').textContent = document.getElementById('metalness').value;
    }
    
    function updateCursor() {
      const sphere = brushCursor.querySelector('a-sphere');
      sphere.setAttribute('radius', brushSize);
      sphere.setAttribute('material', `color: ${currentColor}; opacity: 0.5; transparent: true`);
    }
    
    function updateStatus() {
      document.getElementById('statusBar').textContent = 
        `Ferramenta: ${currentTool === 'draw' ? 'Desenhar' : 'Apagar'} | Cor: ${currentColor} | Strokes: ${strokeCount}`;
    }
    
    function createGrid() {
      const grid = document.getElementById('grid');
      for (let i = -10; i <= 10; i++) {
        const lx = document.createElement('a-entity');
        lx.setAttribute('line', `start: -10 0 ${i}; end: 10 0 ${i}; color: #333`);
        grid.appendChild(lx);
        const lz = document.createElement('a-entity');
        lz.setAttribute('line', `start: ${i} 0 -10; end: ${i} 0 10; color: #333`);
        grid.appendChild(lz);
      }
    }
    
    function getColor() {
      if (document.getElementById('rainbowMode').checked) {
        hue = (hue + 2) % 360;
        return `hsl(${hue}, 100%, 50%)`;
      }
      return currentColor;
    }
    
    function paintAt(x, y, z) {
      if (currentTool === 'erase') {
        eraseAt(x, y, z);
        return;
      }
      
      const color = getColor();
      const glow = document.getElementById('glowEnabled').checked;
      const metal = parseFloat(document.getElementById('metalness').value);
      const mirror = document.getElementById('mirrorMode').checked;
      
      const el = document.createElement('a-entity');
      el.setAttribute('position', `${x} ${y} ${z}`);
      
      let geom, mat;
      if (currentBrush === 'sphere') {
        geom = `primitive: sphere; radius: ${brushSize}`;
      } else if (currentBrush === 'box') {
        geom = `primitive: box; width: ${brushSize*2}; height: ${brushSize*2}; depth: ${brushSize*2}`;
      } else if (currentBrush === 'star') {
        geom = `primitive: octahedron; radius: ${brushSize}`;
      }
      
      mat = `color: ${color}; metalness: ${metal}; roughness: ${1-metal}`;
      if (glow) mat += `; emissive: ${color}; emissiveIntensity: 0.5`;
      
      el.setAttribute('geometry', geom);
      el.setAttribute('material', mat);
      el.classList.add('paint-dot');
      
      container.appendChild(el);
      currentStroke.push(el);
      
      // Mirror
      if (mirror) {
        const el2 = document.createElement('a-entity');
        el2.setAttribute('position', `${-x} ${y} ${z}`);
        el2.setAttribute('geometry', geom);
        el2.setAttribute('material', mat);
        el2.classList.add('paint-dot');
        container.appendChild(el2);
        currentStroke.push(el2);
      }
    }
    
    function eraseAt(x, y, z) {
      const dots = container.querySelectorAll('.paint-dot');
      dots.forEach(dot => {
        const pos = dot.getAttribute('position');
        const dist = Math.sqrt(
          Math.pow(pos.x - x, 2) + 
          Math.pow(pos.y - y, 2) + 
          Math.pow(pos.z - z, 2)
        );
        if (dist < brushSize * 3) {
          dot.parentNode.removeChild(dot);
        }
      });
    }
    
    function startStroke() {
      currentStroke = [];
      isPainting = true;
    }
    
    function endStroke() {
      if (currentStroke.length > 0) {
        strokes.push(currentStroke);
        strokeCount++;
        updateStatus();
      }
      currentStroke = [];
      isPainting = false;
      lastPaintPos = null;
    }
    
    function undoLast() {
      if (strokes.length === 0) return;
      const lastStroke = strokes.pop();
      lastStroke.forEach(el => {
        if (el.parentNode) el.parentNode.removeChild(el);
      });
      strokeCount--;
      updateStatus();
      showToast('Desfeito!');
    }
    
    function clearAll() {
      container.innerHTML = '';
      strokes = [];
      currentStroke = [];
      strokeCount = 0;
      updateStatus();
      showToast('Limpo!');
    }
    
    function exportScene() {
      const dots = container.querySelectorAll('.paint-dot');
      const data = {
        strokes: strokes.map(stroke => stroke.map(el => ({
          position: el.getAttribute('position'),
          geometry: el.getAttribute('geometry'),
          material: el.getAttribute('material')
        })))
      };
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `painting_${Date.now()}.json`;
      a.click();
      showToast('Salvo!');
    }
    
    function importScene(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          clearAll();
          const data = JSON.parse(ev.target.result);
          data.strokes.forEach(strokeData => {
            const stroke = [];
            strokeData.forEach(d => {
              const el = document.createElement('a-entity');
              el.setAttribute('position', d.position);
              el.setAttribute('geometry', d.geometry);
              el.setAttribute('material', d.material);
              el.classList.add('paint-dot');
              container.appendChild(el);
              stroke.push(el);
            });
            strokes.push(stroke);
            strokeCount++;
          });
          updateStatus();
          showToast('Carregado!');
        } catch { showToast('Erro!'); }
      };
      reader.readAsText(file);
      e.target.value = '';
    }
    
    function showToast(msg) {
      const toast = document.getElementById('toast');
      toast.textContent = msg;
      toast.style.display = 'block';
      setTimeout(() => toast.style.display = 'none', 1500);
    }
    
    // Mouse painting (desktop)
    const scene = document.querySelector('a-scene');
    const camera = document.getElementById('camera');
    
    scene.addEventListener('mousedown', (e) => {
      if (e.target.closest('#ui')) return;
      startStroke();
    });
    
    scene.addEventListener('mouseup', endStroke);
    scene.addEventListener('mouseleave', endStroke);
    
    scene.addEventListener('mousemove', (e) => {
      if (!isPainting) return;
      if (e.target.closest('#ui')) return;
      
      // Get camera position and direction
      const cam = camera.object3D;
      const pos = new THREE.Vector3();
      const dir = new THREE.Vector3(0, 0, -1);
      
      cam.getWorldPosition(pos);
      dir.applyQuaternion(cam.quaternion);
      
      // Paint at fixed distance from camera
      const paintDist = 1.5;
      const paintPos = {
        x: pos.x + dir.x * paintDist,
        y: pos.y + dir.y * paintDist,
        z: pos.z + dir.z * paintDist
      };
      
      // Check spacing
      if (lastPaintPos) {
        const dist = Math.sqrt(
          Math.pow(paintPos.x - lastPaintPos.x, 2) +
          Math.pow(paintPos.y - lastPaintPos.y, 2) +
          Math.pow(paintPos.z - lastPaintPos.z, 2)
        );
        if (dist < spacing) return;
      }
      
      paintAt(paintPos.x, paintPos.y, paintPos.z);
      lastPaintPos = paintPos;
    });
    
    // VR controller painting
    const rightHand = document.getElementById('rightHand');
    
    rightHand.addEventListener('triggerdown', startStroke);
    rightHand.addEventListener('triggerup', endStroke);
    
    scene.addEventListener('enter-vr', () => {
      brushCursor.setAttribute('visible', false);
    });
    
    scene.addEventListener('exit-vr', () => {
      brushCursor.setAttribute('visible', true);
    });
    
    // VR paint loop
    setInterval(() => {
      if (!isPainting || !scene.is('vr-mode')) return;
      
      const hand = rightHand.object3D;
      const pos = new THREE.Vector3();
      hand.getWorldPosition(pos);
      
      // Offset slightly forward from controller
      const dir = new THREE.Vector3(0, 0, -0.1);
      dir.applyQuaternion(hand.quaternion);
      pos.add(dir);
      
      if (lastPaintPos) {
        const dist = Math.sqrt(
          Math.pow(pos.x - lastPaintPos.x, 2) +
          Math.pow(pos.y - lastPaintPos.y, 2) +
          Math.pow(pos.z - lastPaintPos.z, 2)
        );
        if (dist < spacing) return;
      }
      
      paintAt(pos.x, pos.y, pos.z);
      lastPaintPos = { x: pos.x, y: pos.y, z: pos.z };
    }, 16);
    
    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undoLast(); }
      if (e.key === 'c') clearAll();
      if (e.key === '1') setTool('draw');
      if (e.key === '2') setTool('erase');
    });
    
    // Init
    scene.addEventListener('loaded', () => {
      createGrid();
      initPalette();
      updateCursor();
      updateStatus();
    });
  </script>
</body>
</html>